#!/bin/sh

#-------------------------------------------------#
#    ____            _       _       _   _ ___    #
#   / ___|  ___ _ __(_)_ __ | |_ ___| | | |_ _|   #
#   \___ \ / __| '__| | '_ \| __/ __| | | || |    # 
#    ___) | (__| |  | | |_) | |_\__ \ |_| || |    # 
#   |____/ \___|_|  |_| .__/ \__|___/\___/|___|   #
#                   |_|                           #
#      https://github.com/kstamand/scriptsui      #
#-------------------------------------------------#
# Author:       kstamand
# Date:         2025-04-31
# Synopsis:     Install and maintain a custom webpage on Asuswrt-Merlin routers
#+      for running predefined scripts and showing results in router's WebUI
# Description:  Installs/uninstals/updates files necessary to add a custom webpage
#+      to an Asuswrt-Merlin based router, which allows for selecting and running
#+      predefined shell scripts on the router and returning the results for dispaly
#+      within the routers web interface
# Reference:    This script is based on Asuswrt-merlin third party addon api
#+      https://github.com/RMerl/asuswrt-merlin/wiki/Addons-API/90b49e443b8ce64e82c0970237199deff46869f5
# Documentation: https://github.com/kstamand/scriptsui
# Credits:      Thanks to dave14305 for his pointers and guidance in devloping this solution
#+              Code in this script modeled after FlexQoS (Dave14305) and SpdMerlin (Jack Yaz)
#----------------------------------------------------------------------------------------------------#

# AsusWRT Merlin Addon API helper functions
source /usr/sbin/helper.sh

### Start of Script Variables
readonly SCRIPT_NAME="scriptsui"
readonly SCRIPT_VERSION="v1.0.0"
readonly SCRIPT_NAME_DISPLAY="ScriptsUI"
readonly GIT_URL=https://raw.githubusercontent.com/kstamand/${SCRIPT_NAME}/master/
readonly ADDON_DIR="/jffs/addons/${SCRIPT_NAME}"
readonly SCRIPT_INSTALL_PATH="${ADDON_DIR}/${SCRIPT_NAME}.sh"
readonly ASP_INSTALL_PATH="${ADDON_DIR}/${SCRIPT_NAME}.asp"
readonly JSON_INSTALL_PATH="${ADDON_DIR}/${SCRIPT_NAME}.json"
readonly WEB_DIR="$(readlink /www/user)" # directory for custom web page to be installed
readonly SCRIPT_WEB_DIR="${WEB_DIR}/${SCRIPT_NAME}" # directory for scriptsui.json and results.js files
readonly EVENT_NAME="scrptsui"  # for some reason, using the name scriptsui for the event would not cause service-event to fire
readonly SCRIPT_LAUNCHER="${SCRIPT_PATH}/scriptlauncher"
readonly LOCK_FILE="/tmp/addonwebui.lock" # lock file to avoid conflicts with other custom WebUI addons
readonly SETTINGS_FILE="/jffs/addons/custom_settings.txt"
readonly SCRIPT_RESULTS_FILE="/www/ext/$SCRIPT_NAME/results.js"
### End of Script Variables

# -x is a flag to show verbose script output for debugging purposes only
Debug(){
    clear
    set -x
    Yellow "Debugging enabled ..."
}

Logmsg() {
    # Parameter options - $1 = message
    if [ "$#" = "0" ]; then #if no parameters passed, then just return
        return
    fi
    logger -t "${SCRIPT_NAME_DISPLAY}" "$*" # display any/all parameters passed
} # end of Logmsg

Red() {
    printf -- '\033[1;31m%s\033[0m\n' "${1}"
}

Green() {
    printf -- '\033[1;32m%s\033[0m\n' "${1}"
}

Yellow() {
    printf -- '\033[1;33m%s\033[0m\n' "${1}"
}

Magenta() {
    printf -- '\033[1;35m%s\033[0m\n' "${1}"
}

Cyan() {
    printf -- '\033[1;36m%s\033[0m\n' "${1}"
}

Scriptinfo() {
    # Version header used in interactive sessions
    [ "${mode}" = "interactive" ] || return
    printf "\n"
    Green "${SCRIPT_NAME_DISPLAY} ${SCRIPT_VERSION}"
    printf "\n"
} # end of Scriptinfo ()

About() {
    Scriptinfo
    cat <<EOF
License
${SCRIPT_NAME_DISPLAY} is free to use under the GNU General Public License, version 3 (GPL-3.0).
https://opensource.org/licenses/GPL-3.0

For discussion visit this thread:
https://www.snbforums.com/forums/asuswrt-merlin-addons.60/?prefix_id=8
https://github.com/kstamand/scriptsui (Source Code)

About
Script maintains a Custom Webpage for selecting, running, and displaying script results
Reason - for those wishing to do as much as they can in the Router WebUI and avoid SSH for simple / informational commands
EOF
} # end of about() information

Check_Firmware() {
    Cyan "   - Checking firmware support"
    if ! nvram get rc_support | grep -q am_addons; then
        Red "${SCRIPT_NAME_DISPLAY} requires ASUSWRT-Merlin Addon API support. Installation aborted."
        return 1
    fi
    if [ "$(nvram get jffs2_scripts)" != "1" ]; then
        Red "\"Enable JFFS custom scripts and configs\" is not enabled. Please enable it in the GUI. Aborting installation."
        return 1
    fi
} # end of Check_Firmware()

Press_Enter(){
    [ "${mode}" = "interactive" ] || return
    printf "\n"
    while true; do
        printf "Press enter to continue..."
        read -r "key"
        case "${key}" in
            *)
                break
            ;;
        esac
    done
    return 0
} # end of Press_Enter()

Main_Menu() {

    local yn
    [ "${mode}" = "interactive" ] || return
    clear
    sed -n '2,11p' "${0}"		# display banner
    Scriptinfo
    printf "  (1) About        explain functionality\n"
    printf "  (2) Install      install scriptsui files\n"
    printf "  (3) Update       check for updates\n"
    printf "  (4) Startup      ONLY meant for when router bootsup\n"
    printf "  (5) Run          run script selected from custom webpage\n"
    printf "  (6) Debug        enable verbose logging for troubleshooting\n"
    printf "  (7) Uninstall    completely remove scriptsui from the router\n"
    printf "  (e) Exit         exit without doing anything\n"
    printf "\nMake a selection: "
    read -r input
    case "${input}" in
        '1')
            clear
            about
            prinf "\nHit enter to continue"
            read -r input
        ;;
        '2')
            Install
        ;;
        '3')
            Update
        ;;
        '4')
            Startup
        ;;
        '5')
            Run
        ;;
        '6')
            Debug
        ;;
        '7')
            Uninstall
        ;;
        'e'|'E'|'exit')
            return
        ;;
        *)
            printf "\n"
            Red "[ERROR] $input is not a valid option!"
            printf "n"
            exit 5
        ;;
    esac
    Press_Enter
    Main_Menu		# stay in the menu loop until exit is chosen
} # end of Main_Menu()

Download_File() {
    # Parameter options: $1 = file name to download, $2 = full path + filename to download to
    # Download file from Github once to a temp location. If the same as the destination file, don't replace.
    # Otherwise move it from the temp location to the destination.
    if curl -fsL --retry 3 --connect-timeout 3 "${GIT_URL}/${1}" -o "/tmp/${1}"; then
        if [ "$(md5sum "/tmp/${1}" | awk '{print $1}')" != "$(md5sum "${2}" 2>/dev/null | awk '{print $1}')" ]; then
            mv -f "/tmp/${1}" "${2}"
            Cyan "   Installed $(basename "${1}")"
        else
            Yellow "  File $(basename "${2}") is already up-to-date"
            rm -f "/tmp/${1}" 2>/dev/null
        fi
    else
        Red "   [ERROR] Install $(basename "${1}") failed"
    fi
} # end of Download_File()

Auto_Start(){
    # Parameters: $1 - install or uninstall
    case $1 in
        install)
            Cyan "   -  Inserting $SCRIPT_NAME post-mount line"
            # check if a post-mount file exists and process as follows
			if [ -f /jffs/scripts/post-mount ]; then
				STARTUPLINECOUNT=$(grep -c '# '"$SCRIPT_NAME" /jffs/scripts/post-mount)
				STARTUPLINECOUNTEX=$(grep -cx 'if echo "$2" | /bin/grep -q "'"$SCRIPT_NAME"'"; then { /jffs/scripts/'"$SCRIPT_NAME"' post-mount "$@" & }; fi # '"$SCRIPT_NAME" /jffs/scripts/post-mount)
				# delete existing comment line if it exists - cleanup any residual stuff
				if [ "$STARTUPLINECOUNT" -gt 1 ] || { [ "$STARTUPLINECOUNTEX" -eq 0 ] && [ "$STARTUPLINECOUNT" -gt 0 ]; }; then
					sed -i -e '/# '"$SCRIPT_NAME"'/d' /jffs/scripts/post-mount
				fi
				# insert post-mount line for scriptsui
				if [ "$STARTUPLINECOUNTEX" -eq 0 ]; then
					echo " " >> /jffs/scripts/post-mount
                    echo "$SCRIPT_INSTALL_PATH startup    # $SCRIPT_NAME custom webpage router WebUI install" >> /jffs/scripts/post-mount
				fi
			# a service-event file did not exist, so create one
            else
				echo "#!/bin/sh" > /jffs/scripts/post-mount
				echo "" >> /jffs/scripts/post-mount
				echo "$SCRIPT_FILE_PATH startup    # $SCRIPT_NAME custom webpage router WebUI install" >> /jffs/scripts/post-mount
				chmod 0755 /jffs/scripts/post-mount
			fi
        ;;
        uninstall)
			Cyan "   - Removing $SCRIPT_NAME from post-mount"
            # check if service event line exists and if so, remove any scriptsui lines found
            if [ -f /jffs/scripts/post-mount ]; then
				STARTUPLINECOUNT=$(grep -c '# '"$SCRIPT_NAME" /jffs/scripts/post-mount)
				
				if [ "$STARTUPLINECOUNT" -gt 0 ]; then
					sed -i -e '/# '"$SCRIPT_NAME"'/d' /jffs/scripts/post-mount
				fi
			fi
        ;;
    esac
} # end of Auto_Start()

Auto_ServiceEvent(){
    # Parameters: $1 - install or uninstall
    # Credits to Jack Yaz, this code borrowed from spdMerlin
	case $1 in
		install)
            Cyan "   -  Inserting $SCRIPT_NAME service-event line"
            # check if a service-event file exists and process as follows
			if [ -f /jffs/scripts/service-event ]; then
				STARTUPLINECOUNT=$(grep -c '# '"$SCRIPT_LAUNCHER" /jffs/scripts/service-event)
				STARTUPLINECOUNTEX=$(grep -cx 'if echo "$2" | /bin/grep -q "'"$SCRIPT_LAUNCHER"'"; then { '"$SCRIPT_INSTALL_PATH"' service_event "$@" & }; fi # '"$SCRIPT_NAME" /jffs/scripts/service-event)
				# delete existing comment line if it exists - cleanup any residual stuff
				if [ "$STARTUPLINECOUNT" -gt 1 ] || { [ "$STARTUPLINECOUNTEX" -eq 0 ] && [ "$STARTUPLINECOUNT" -gt 0 ]; }; then
					sed -i -e '/# '"$SCRIPT_LAUNCHER"'/d' /jffs/scripts/service-event
				fi
				# insert start-event line for scriptsui
				if [ "$STARTUPLINECOUNTEX" -eq 0 ]; then
					echo 'if echo "$2" | /bin/grep -q "'"$SCRIPT_LAUNCHER"'"; then { '"$SCRIPT_INSTALL_PATH"' service_event "$@" & }; fi # '"$SCRIPT_NAME" >> /jffs/scripts/service-event
				fi
			# a service-event file did not exist, so create one
            else
				echo "#!/bin/sh" > /jffs/scripts/service-event
				echo "" >> /jffs/scripts/service-event
				echo 'if echo "$2" | /bin/grep -q "'"$SCRIPT_LAUNCHER"'"; then { '"$SCRIPT_INSTALL_PATH"' service_event "$@" & }; fi # '"$SCRIPT_NAME" >> /jffs/scripts/service-event
				chmod 0755 /jffs/scripts/service-event
			fi
		;;
		uninstall)
			Cyan "   - Removing $SCRIPT_NAME from service-event"
            # check if service event line exists and if so, remove any scriptsui lines found
            if [ -f /jffs/scripts/service-event ]; then
				STARTUPLINECOUNT=$(grep -c '# '"$SCRIPT_LAUNCHER" /jffs/scripts/service-event)
				
				if [ "$STARTUPLINECOUNT" -gt 0 ]; then
					sed -i -e '/# '"$SCRIPT_LAUNCHER"'/d' /jffs/scripts/service-event
				fi
			fi
		;;
	esac
} # end of Auto_ServiceEvent()

Setup_Aliases() {
    # Parameters: $1 - install or uninstall
    # shortcuts to launching script
    case $1 in
        install)
            # remove shell alias
            local cmdline
            if [ -d /opt/bin ]; then
                # Entware is installed, so setup link to /opt/bin
                Cyan "   - Adding ${SCRIPT_NAME} link in Entware /opt/bin"
                ln -sf "${SCRIPT_INSTALL_PATH}" "/opt/bin/${SCRIPT_NAME}"
            else
                # Setup shell alias
                Cyan "   -  Adding ${SCRIPT_NAME} alias in profile.add"
                sed -i "/alias ${SCRIPT_NAME}/d" /jffs/configs/profile.add 2>/dev/null
                cmdline="alias ${SCRIPT_NAME}=\"sh ${SCRIPT_INSTALL_PATH}\" # ${SCRIPT_NAME_DISPLAY} Addition"
                echo "${cmdline}" >> /jffs/configs/profile.add
            fi
        ;;
        uninstall)
            # remove alias from profile.add. Brute force, meaning not checking to see if exists first, just assume and delete
            if [ -f /opt/bin/${SCRIPT_NAME} ]; then
                # Entware is installed, so setup link to /opt/bin
                Cyan "   - Deleting ${SCRIPT_NAME} link in Entware /opt/bin"
                rm "/opt/bin/${SCRIPT_NAME}"
            else
                # Remove alias from profile.add
                Cyan "   -  Deleting ${SCRIPT_NAME} alias in profile.add"
                if [ -f /jffs/configs/profile.add ]; then
                    STARTUPLINECOUNT=$(grep -c '# '"$SCRIPT_NAME" /jffs/configs/profile.add)
                    
                    if [ "$STARTUPLINECOUNT" -gt 0 ]; then
                        sed -i -e '/# '"$SCRIPT_NAME"'/d' /jffs/configs/profile.add
                    fi
                fi
            fi  
        ;;
    esac
} #  end of Setup_Aliases()

### Code for these functions inspired by https://github.com/Adamm00 - credit to @Adamm ###
Check_Lock(){
	if [ -f "$LOCK_FILE" ]; then
		while [ "$ageoflock" -gt 600 ]; do
            ageoflock=$(($(date +%s) - $(date +%s -r $LOCK_FILE)))
            if [ "$ageoflock" -gt 600 ]; then
                Logmsg "Stale lock file found (>600 seconds old) - purging lock"
                kill "$(sed -n '1p' $LOCK_FILE)" >/dev/null 2>&1
                Clear_Lock
                echo "$$" > "$LOCK_FILE"
                return 0
            else
                Logmsg "Lock file found (age: $ageoflock seconds) - pausing 10 seconds to prevent duplicate runs"
                sleep 10
            fi
        done
	else
		echo "$$" > "$LOCK_FILE"
		return 0
	fi
}

Clear_Lock(){
	rm -f "$LOCK_FILE" 2>/dev/null
	return 0
} # end of Clear_Lock()

NTP_Ready(){
	if [ "$(nvram get ntp_ready)" -eq 0 ]; then
		ntpwaitcount=0
		Check_Lock
		while [ "$(nvram get ntp_ready)" -eq 0 ] && [ "$ntpwaitcount" -lt 600 ]; do
			ntpwaitcount="$((ntpwaitcount + 30))"
			Logmsg "Waiting for NTP to sync..."
			sleep 30
		done
		if [ "$ntpwaitcount" -ge 600 ]; then
			Logmsg "NTP failed to sync after 10 minutes. Please resolve!"
			Clear_Lock
			exit 1
		else
			Logmsg "NTP synced, $SCRIPT_NAME will now continue"
			Clear_Lock
		fi
	fi
} # end of NTP_Ready()

### function based on @Adamm00's Skynet USB wait function ###
Entware_Ready(){
	if [ ! -f "/opt/bin/opkg" ]; then
		Check_Lock
		sleepcount=1
		while [ ! -f /opt/bin/opkg ] && [ "$sleepcount" -le 10 ]; do
			Logmsg "Entware not found, sleeping for 10s (attempt $sleepcount of 10)"
			sleepcount="$((sleepcount + 1))"
			sleep 10
		done
		if [ ! -f /opt/bin/opkg ]; then
			Logmsg "Entware not found and is required for $SCRIPT_NAME to run, please resolve" "$CRIT"
			Clear_Lock
			exit 1
		else
			Logmsg "Entware found, $SCRIPT_NAME will now continue"
			Clear_Lock
		fi
	fi
}
### ###

Install_Webui() {
    # Parameters: None
    Cyan "   - Installing Webui"

    local prev_webui_page
    # Check if the webpage is already mounted in the GUI and reuse that page
    prev_webui_page="$(sed -nE "s/^\{url\: \"(user[0-9]+\.asp)\"\, tabName\: \"${SCRIPT_NAME_DISPLAY}\"\}\,$/\1/p" /tmp/menuTree.js 2>/dev/null)"
    if [ -n "${prev_webui_page}" ]; then
        # use the same filename as before
        am_webui_page="${prev_webui_page}"
    else
        # get a new mountpoint
        am_get_webui_page "${ASP_INSTALL_PATH}"
    fi
    if [ "${am_webui_page}" = "none" ]; then
        if [ ! "${mode}" = "interactive" ]; then
            Logmsg "No API slots available to install web page"
            exit 5
        else
            Red "...   No API slots available to install web page"
            exit 5
        fi
    else
        cp -p "${ASP_INSTALL_PATH}" "/www/user/${am_webui_page}"
        Logmsg "Custom Web Page added using ${am_webui_page}"
        if [ ! -f /tmp/menuTree.js ]; then
            cp /www/require/modules/menuTree.js /tmp/
            mount -o bind /tmp/menuTree.js /www/require/modules/menuTree.js
        fi
        if ! /bin/grep -q "{url: \"$am_webui_page\", tabName: \"${SCRIPT_NAME_DISPLAY}\"}," /tmp/menuTree.js; then
            umount /www/require/modules/menuTree.js 2>/dev/null
            sed -i "/url: \"Tools_OtherSettings.asp\", tabName:/a {url: \"$am_webui_page\", tabName: \"$SCRIPT_NAME_DISPLAY\"}," /tmp/menuTree.js
            mount -o bind /tmp/menuTree.js /www/require/modules/menuTree.js
        fi
    fi
    # Remove lock control
    Clear_Lock

    # Copy over the json file that the custom webpage reads to populate the list of available script to run and display results for
    cp -p "$JSON_INSTALL_PATH" "${SCRIPT_WEB_DIR}"
} # end of Install_Webui()

Custom_Settings(){
    # Parameters: $1 - install or uninstall
    # Add / delete a name space in the Asuswrt third party addons custome_settings.txt file
    case $1 in
        install)
            Cyan "   - Creating ${SCRIPTS_NAME_DISPLAY} cusotom_settings.txt name space"
            # check if any previous name space entries exist and remove them
			if [ -f $SETTINGS_FILE ]; then
				STARTUPLINECOUNT=$(grep -c "$SCRIPT_NAME_DISPLAY" $SETTINGS_FILE)
				# delete existing comment line if it exists - cleanup any residual stuff
				if [ "$STARTUPLINECOUNT" -gt 0 ]; then
					sed -i -e  '/'"$SCRIPT_NAME_DISPLAY"'/d' $SETTINGS_FILE
				else
                    am_settings_set "${SCRIPT_NAME_DISPLAY}"_ver "${SCRIPT_VERSION}"
				fi
			# a service-event file did not exist, so create one
            else
				am_settings_set "${SCRIPT_NAME_DISPLAY}"_ver "${SCRIPT_VERSION}"
			fi
        ;; 
        uninstall)
            Cyan "   - Deleting ${SCRIPTS_NAME_DISPLAY} cusotom_settings.txt name space"
            # check if any previous name space entries exist and remove them
			if [ -f $SETTINGS_FILE ]; then
				STARTUPLINECOUNT=$(grep -c '# '"$SCRIPT_NAME_DISPLAY" $SETTINGS_FILE)
				# delete existing comment line if it exists - cleanup any residual stuff
				if [ "$STARTUPLINECOUNT" -gt 0 ]; then
					sed -i -e  '/'"$SCRIPT_NAME_DISPLAY"'/d' $SETTINGS_FILE
				fi
            fi
        ;;
    esac
} # end of Custom_Settings

Uninstall_Webui() {
	local prev_webui_page
	Cyan "   - Removing WebUI"
	prev_webui_page="$(sed -nE "s/^\{url\: \"(user[0-9]+\.asp)\"\, tabName\: \"${SCRIPT_NAME_DISPLAY}\"\}\,$/\1/p" /tmp/menuTree.js 2>/dev/null)"
	if [ -n "${prev_webui_page}" ]; then
		# Remove page from the UI menu system
		Check_Lock
		umount /www/require/modules/menuTree.js 2>/dev/null
		sed -i "\~tabName: \"${SCRIPT_NAME_DISPLAY}\"},~d" /tmp/menuTree.js
		if diff -q /tmp/menuTree.js /www/require/modules/menuTree.js >/dev/null 2>&1; then
			# no more custom pages mounted, so remove the file
			rm /tmp/menuTree.js
		else
			# Still some modifications from another script so remount
			mount -o bind /tmp/menuTree.js /www/require/modules/menuTree.js
		fi
		Clear_Lock
		# Remove last mounted asp page
		rm -f "/www/user/${prev_webui_page}" 2>/dev/null
	fi
} # end of Uninstall_Webui

Install() {
    # Parameter options: None
    # Install script and download webui file
    # This is also called by the update process once a new script is downloaded by update() function
    if [ ! "${mode}" = "interactive" ]; then
        Logmsg "[ERROR] Install function can only be run interactively"
        exit 5
    fi
    clear
    Scriptinfo
    Green "Installing ${SCRIPT_NAME_DISPLAY}"
    if ! Check_Firmware; then
        Red "[ERROR] Addons are not supported in this routers firmware - script aborting!!!"
        Press_Enter
        rm -f "${0}" 2>/dev/null
        exit 5
    fi
    # Create the directory for the ScriptsUI addon files
    if [ ! -d "${ADDON_DIR}" ]; then
        Cyan "   - Creating $SCRIPT_NAME ADDON directory..."
        mkdir -p "${ADDON_DIR}"
        chmod 755 "${ADDON_DIR}"
    fi
    # Create the Web Directory for the SciptsUI JSON and Results files
    if [ ! -d "${SCRIPT_WEB_DIR}" ]; then
        Cyan "   - Creating $SCRIPT_NAME Web directory..."
        mkdir -p "${SCRIPT_WEB_DIR}"
        chmod 755 "${SCRIPT_WEB_DIR}"
    fi

    # download all scriptsui files
    Cyan "   - Downloading $(basename "${SCRIPT_INSTALL_PATH}")"
    Download_File "$(basename "${SCRIPT_INSTALL_PATH}")" "${SCRIPT_INSTALL_PATH}" #scriptsui.sh
    chmod 755 ${SCRIPT_INSTALL_PATH} # make script executable

    Cyan "   - Downloading $(basename "${ASP_INSTALL_PATH}")"
    Download_File "$(basename "${ASP_INSTALL_PATH}")" "${ASP_INSTALL_PATH}" #custom webpage 

    Cyan "   - Downloading $(basename "${JSON_INSTALL_PATH}")"
    Download_File "$(basename "${JSON_INSTALL_PATH}")" "${JSON_INSTALL_PATH}" #sample json file of scripts to display in custom webpage

    # add command line to /jffs/scripts/post-mount to install the custom webpage when router bootsup
    Auto_Start install
    
    # add command line to /jffs/scripts/service-event to handle and launch scripts selected from custom webpage to run
    Auto_ServiceEvent install

    # add alias command for invoking script
    Setup_Aliases install

    # install the custom webpage to router UI
    Cyan "   - Installing Custom Webpage"
    Install_Webui

    # create Asuswrt third party addon name space with version information
    Custom_Settings install

    # Install complete messages
    Magenta "  ${SCRIPT_NAME_DISPLAY} is installed under the TOOLS section of the Router UI"
    Magenta "  >> update the $(basename "${JSON_INSTALL_PATH}") file with the list of scripts you want in ${SCRIPT_NAME_DISPLAY}"
    printf ""
    Green "${SCRIPT_NAME_DISPLAY} installation complete!"
} # end of Install()

Startup(){
    # Parameters: None
    # This function installs the ScriptsUI custom webpage during router bootup
    
    Logmsg "Installing WebUI tab for ScriptsUI"

    # Check the lock file to see if we can proceed
    Check_Lock

    # Create the Web Directory for the SciptsUI JSON and Results files
    if [ ! -d "${SCRIPT_WEB_DIR}" ]; then
        Logmsg "Creating $SCRIPT_NAME Web directory..."
        mkdir -p "${SCRIPT_WEB_DIR}"
        chmod 755 "${SCRIPT_WEB_DIR}"
    fi

    # Install scriptsui custom webpage in router WebUI
    Install_Webui

    # end messaging
    Logmsg "Completed install of WebUI tab for ScriptsUI"
} # end of Startup()

Update() {
    # Check for, and optionally apply updates.
    # Parameter options: check (do not update), silent (update without prompting)
    local updatestatus yn remotever
    Scriptinfo
    Green "Checking for updates"
    # Update the webui status thorugh detect_update.js ajax call.
    # Get the version of the script on Github
    remotever="$(curl -fsN --retry 3 --connect-timeout 3 "${GIT_URL}/$(basename "${SCRIPT_INSTALL_PATH}")" | /bin/grep "^version=" | sed -e 's/version=//')"
    # Compare local and remote versions to see how to proceed
    if [ "$( echo "${SCRIPT_VERSION}" | sed 's/\.//g' )" -lt "$( echo "${remotever}" | sed 's/\.//g' )" ]; then		# strip the . from version string for numeric comparison
        # version upgrade
        updatestatus="Update"
    else
        updatestatus="NoUpdate"
    fi

    if [ "${1}" = "check" ]; then
        # Do not proceed with any updating if check function requested
        return
    fi

    if [ "${mode}" = "interactive" ] && [ -z "${1}" ]; then
        case "${updatestatus}" in
        'NoUpdate')
            Cyan "   - You have the latest version installed"
            printf " Would you like to overwrite your existing installation anyway? [1=Yes 2=No]: "
            ;;
        'Update')
                    # New Version Number
            Cyan "   - ${SCRIPT_NAME_DISPLAY} v${updatestatus} is now available!"
            printf " Would you like to update now? [1=Yes 2=No]: "
            ;;
        *)
            Red "   - Error occured checking version information"
            Press_Enter
            return
            ;;
        esac
        read -r yn
        printf "\n"
        if [ "${yn}" = "n" ] || [ "${yn}" = "N" ]; then
            Cyan "   - No Changes have been made"
            return 0
        fi
    fi
    Cyan "   - Installing latest version of ${SCRIPT_NAME_DISPLAY}"
    Download_File "$(basename "${SCRIPT_INSTALL_PATH}")" "${SCRIPT_INSTALL_PATH}"
    Install
    exit
} # end of Update()

Uninstall() {
    # Parameters options: None
    if [ ! "${mode}" = "interactive" ]; then
        Logmsg "[ERROR] Uninstall function can only be run interactively"
        exit 5
    fi
    clear
    Scriptinfo
    Green "Uninstalling ${SCRIPT_NAME_DISPLAY}"

    # Remove scriptsui from post-mount
    Auto_Start uninstall

    # Remove scriptsui from service-event 
    Auto_ServiceEvent uninstall

    # Remove scriptsui alias from System and Profile.add
    Setup_Aliases uninstall

    # Remove Custom Webpage
    Uninstall_Webui

     # delet Asuswrt third party addon name space with version information
    Custom_Settings uninstall

    # Remove directories
    if [ -d "${ADDON_DIR}" ]; then
        Cyan "   - deleting $SCRIPT_NAME ADDON directory..."
        rm -rf "${ADDON_DIR}" 2>/dev/null	
    fi

    # Create the Web Directory for the SciptsUI JSON and Results files
    if [ -d "${SCRIPT_WEB_DIR}" ]; then
        Cyan "   - Deleting $SCRIPT_NAME Web directory..."
        rm -rf "${SCRIPT_WEB_DIR}" 2>/dev/null	
    fi
} # end of Uninstall()

Run_Script() {
    local string scriptname line path
    # strip off the string "scrptsui"(first  characters) from the the name ($3) passed in to this script
    string=$1 #pick up name passed
    scriptname="${string:8}" #remove first 8 characters

    # now find which line in scriptsui.json file contains that scriptname
    line="$(grep ${scriptname} ${JSON_FILE_PATH})"

    # now pick up the full path of script to execute that matched the scriptname in the json file 
    #+ matching line example >> {"name":"brctl","path":"/jffs/addons/scriptsui/brctl_show.sh"},
    ## startpos="$(echo ${line} | grep  -b -o path | cut -d: -f1)" # find start positon of the string path
    ## cutstartpos=$((startpos+11)) # add 11 to where the start of the word path was found
    path="$(echo "$line" | awk -F '"' '{print $8}')"

    # last, run the script that matches the script name passed to us and was found in the json file
    if ! [ -f $path ]; then
        echo "[ERROR] $path not found. Create the script and try again." > "$SCRIPT_RESULTS_FILE"
    else 
        Logmsg "Running script $path"
        sh $path
    fi
} # end of Run_Script

###---###---### Script Mainline ###---###---###

# Detect if script is run from an SSH shell interactively or from the WebUI (unattended)
if tty >/dev/null 2>&1; then
    mode="interactive"
else
    mode="unattended"
fi

# Make sure the version in custom_settings.txt matches the version of this script
if [ "$(am_settings_get "${SCRIPT_NAME_DISPLAY}"_ver)" != "${SCRIPT_VERSION}" ]; then
	am_settings_set "${SCRIPT_NAME_DISPLAY}"_ver "${SCRIPT_VERSION}"
fi

# Check and process the parameter passed when calling this script
case "$1" in
    'menu'|'')
        Main_Menu
    ;;
    'install')
        Install
    ;;
    'update')
        Update
    ;;
    'startup')
        # Check to make sure NTP and Entware are ready before continuing, exit if not
        NTP_Ready
        Entware_Ready
        Startup
    ;;
    'run')
        # the Service-event that calls this script passes 3 arguements (run start scriptpath)
        #+ scriptpath is read from the scriptsui.json file that matches the name passed from WebUI
        Run_Script $3
    ;;
    'debug')
        Debug
    ;;
    'uninstall')
        Uninstall
    ;;
    *)
        if [ ! "${mode}" = "interactive" ]; then
            Logmsg "[ERROR] >> $1 << is an unknown parameter; scripted ended unexpectedly"
            exit 5
        else
            printf "\n"
            Red "[ERROR] >> $1 << is not a valid option!"
            printf "\n"
            exit 5
        fi
    ;;
esac
